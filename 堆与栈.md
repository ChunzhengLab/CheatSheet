# 堆栈与内存管理简例

## Question

这三种情况下，b0,b1,b2和它们内部的a0,a1,a2在栈上还是堆上？当b0,b1,b2离开作用域后，其内部的a0,a1,a2还存在吗？

```C++
class A {
public:
  A() {}
  ~A() {}
private:
  float x;
};

class B {
public:
  B() {}
  ~B() {
    //delete a1;
  }
private:
  A a0;
  A* a1 = new A();
  unique_ptr<A> a2 = make_unique<A>();
};

int main() {
  //0. Create an object on the stack
  B b0;

  //1. Create an object on the heap
  B* b1 = new B();
  //delete b1;

  //2. Create an object on the heap using unique_ptr
  unique_ptr<B> b2 = make_unique<B>();

  return 0;
}
```
## Answer
  
`B` 类包含三个 `A` 类型的成员：`a0`、`a1` 和 `a2`。它们在内存中的位置和存储方式取决于 `B` 的实例化方式以及它们各自的定义。让我们逐个讨论：

### 0. 栈上的对象 `b0`

- **`b0`**：在栈上。`B b0;` 这行代码在栈上创建了 `B` 类的一个实例。
  - **`a0`**：作为 `b0` 的成员，同样在栈上。
  - **`a1`**：指针本身存储在栈上，但它指向的 `A` 类型的对象是通过 `new` 关键字在堆上动态分配的。
  - **`a2`**：智能指针（`unique_ptr<A>`）本身存储在栈上，但它管理的 `A` 类型的对象是在堆上创建的。

当 `b0` 离开作用域时：
- **`a0`**：随着 `b0` 的析构而被销毁。
- **`a1`**：指针所指向的堆上对象不会自动被销毁（除非显式调用 `delete`，但在这里被注释掉了），这可能会导致内存泄漏。
- **`a2`**：智能指针会自动释放它所管理的堆上对象。

### 1. 堆上的对象 `b1`

- **`b1`**：是一个指针，在栈上，但它指向的 `B` 类型的对象是通过 `new` 在堆上动态分配的。
  - **`a0`**：作为 `b1` 指向的对象的成员，在堆上。
  - **`a1`**：指针本身存储在 `b1` 指向的对象内部（因此在堆上），它指向的 `A` 类型的对象也在堆上。
  - **`a2`**：作为 `b1` 指向的对象的成员，智能指针本身在堆上，它管理的对象也在堆上。

当通过 `delete b1;` 显式删除 `b1` 指向的对象时：
- **`a0`**：随着 `b1` 指向的 `B` 对象的析构而被销毁。
- **`a1`**：需要显式通过 `delete` 来销毁，否则会造成内存泄漏。在你的代码中，`delete a1;` 被注释掉了，所以如果没有取消注释，`a1` 指向的对象将不会被销毁。
- **`a2`**：智能指针会自动释放它所管理的对象。

### 2. 堆上的对象 `b2`

- **`b2`**：是一个智能指针，存储在栈上，但它管理的 `B` 类型的对象是在堆上创建的。
  - **`a0`**：作为 `b2` 管理的对象的成员，在堆上。
  - **`a1`**：指针本身存储在 `b2` 管理的对象内部（因此在堆上），它指向的 `A` 类型的对象也在堆上。
  - **`a2`**：作为 `b2` 管理的对象的成员，智能指针本身在堆上，它管理的对象也在堆上。

当 `b2` 的智能指针离开作用域时：
- **`a0`**：随着 `b2` 管理的 `B` 对象的析构而被销毁。
- **`a1`**：需要显式通过 `delete` 来销毁，否则会造成内存泄漏。在你的代码中，`delete a1;` 被注释掉了，所以如果没有取消注释，`a1` 指向的对象将不会被销毁。
- **`a2`**：智能指针会自动释放它所管理的对象。
